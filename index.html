<!DOCTYPE html>
<html>
<head>
    <title>W2UI Demo: layout/4</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script type="text/javascript" src="https://rawgit.com/vitmalina/w2ui/master/dist/w2ui.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://rawgit.com/vitmalina/w2ui/master/dist/w2ui.min.css" />
	<script src="https://d3js.org/d3.v6.min.js"></script>
	<script type='text/javascript' > 
		var objs;
		var data;
        var objectsByDots;

        function compareLocation(loc1, loc2) {
            return String(loc1.x) == String(loc2.x) && String(loc1.y) == String(loc2.y)
        }

        function getFragmentName(x, y, index) {
          return "(" + x + ", " + y + ")-" + index
        }
	</script>
</head>
<body>

<div id="layout" style="width: 100%; height: 800px;"></div>

<style>
.w2ui-sidebar[name=navigation] .w2ui-node-handle > div{
    width: 11px;
    height: 11px;
    border-radius: 10px;
    margin-left: 15px;
    margin-top: 7px;
    display: inline-block;
    background-color: #e1e1e1;
    border: 1px solid transparent
}
.w2ui-sidebar[name=navigation] .w2ui-sidebar-body .w2ui-node .w2ui-node-handle > div:hover {
    border: 1px solid #55ca2e
}
.w2ui-sidebar[name=navigation] .w2ui-sidebar-body .w2ui-node .w2ui-node-handle > div.toggle {
    background-color: #55ca2e;
    border: 1px solid #55ca2e
}
</style>
<div style="clear: both"/>



<script type="text/javascript">
$(function () {
    var pstyle = 'border: 1px solid #efefef; padding: 5px;';
    $('#layout').w2layout({
        name: 'layout',
        panels: [
            { type: 'top', style: pstyle, content: 'top', resizable: true },
            { type: 'left', size: 300, style: pstyle, content: 'left', resizable: true },
            { type: 'main', style: pstyle, html: `<div id='map'></div>`, resizable: false },
			      { type: 'right', content: 'right', resizable: true }
            //https://stackoverflow.com/questions/16510991/how-can-i-make-a-layout-widget-expand-to-full-height-in-w2ui
        ]
    });
    var bp = []

  $().w2toolbar({
    name: 'main-toolbar',
    items: [
      { type: 'button', id: 'reset', text: 'Reset' },
      { type: 'button', id: 'save-export', text: 'Save/Export', onClick() { w2confirm({
        msg: saveToCode(),
        title: 'Confirmation',
        width: 450,        // width of the dialog
        height: 220,       // height of the dialog
        btn_yes: {
            text  : 'Copy', // text for yes button (or yes_text)
            class : '',    // class for yes button (or yes_class)
            style : '',    // style for yes button (or yes_style)
            click : console.log(JSON.stringify(state))   // callBack for yes button (or yes_callBack)
            // Maybe see if we can copy it to the clickboard automatically with this
        },
        btn_no: {
            text  : 'Close',  // text for no button (or no_text)
            class : '',    // class for no button (or no_class)
            style : '',    // style for no button (or no_style)
            click : null   // callBack for no button (or no_callBack)
        },
        callBack: null,    // common callBack
        onOpen: null,      // event when popup is opened
        onClose: null      // event when popup is closed
      })}},

      { type: 'button', id: 'load', text: 'Load', onClick() { w2prompt({
          label: 'Enter',
          value: '2',
          attrs: 'style="width: 200px"',
          title: w2utils.lang('Notification'),
          ok_text: w2utils.lang('Ok'),
          ok_class: 'ok-class',
          cancel_text: w2utils.lang('Cancel'),
          cancel_class: 'cancel-class',
          width: 400,
          height: 200
      })
      .change((event) => {
          console.log('change', event);
      })
      .ok((event) => {
          console.log(event)
          loadFromCode(event);
      });}}
    ]
  })

  function saveExport() {
      
    }

  $().w2layout({
    name: 'left-pane',
    panels: [
      { type: 'top', size: 50, style: pstyle},
      { type: 'main', size: 500, style: pstyle, resizable: true },
      { type: 'bottom', size: 200, style: pstyle }
    ]
  });

  $().w2toolbar({
    name: 'navigation-toolbar',
    items: [
      { type: 'menu-radio', id: 'navigation-sortby',
          text(item) {
            let text = item.selected;
            let el = this.get('navigation-sortby:' + item.selected);
            return 'Sort by: ' + el.text;
          },
          selected: 'sortby-name',
          items: [
            { id: 'sortby-name', text: 'Name' },
            { id: 'sortby-type', text: 'Type' },
            { id: 'sortby-id', text: 'ID'}
          ]
      },
      { type: 'menu-check', id: 'navigation-filter', text: 'Filter',
        selected: ['lot', 'kw'],
        onRefresh(event){
          console.log(event)
          event.item.count = event.item.selected.reduce((a,b) => a + event.item.items.find(i => i.id == b).count, 0);
        },
        items: [
          { id: 'kw', text: 'KW', count: 100 },
          { id: 'lot', text: 'Lots', count: 400}
        ]
      }
    ]
  })

	$().w2sidebar({
		name: 'navigation',
		img: null,
		handle: {
			size: 18,
			//style: 'height: 22px; width: 20px; margin-top: 0px; margin-left: -15px;',
			content: `<div onclick="w2ui.navigation.toggle(this, event)"
                ${w2utils.tooltip('Toggle visability', { className: 'w2ui-light', left: -6, position: 'top|bottom' })}></div>`
		},
		nodes: [],
		toggle(el) {
            // shoulda probably have done this D3 style?
			let node = $(el).closest('.w2ui-node');
			//let nodeID = $(el).closest('.w2ui-node').attr('id')
      let id = node[0].id.substring(5) //dangerous should use regex
  
      if (bp.indexOf(id) != -1) { // Is visible
          bp.splice(bp.indexOf(id), 1)
          $(el).removeClass('toggle')
          hideObject(id, true)

      } else {    // Is hidden
          bp.push(id)
          $(el).addClass('toggle')
          console.log(id)
          hideObject(id, false)
          
      }
      event.preventDefault()
      event.stopPropagation()
		}
	});
    
	$().w2sidebar({
		name: 'filter',
		img: null,
		nodes: [
			{ id: 'show', text: 'Show',
          nodes: [
              { id: 'show-rocks', text: 'Rocks' },
              { id: 'show-lines', text: 'Lines' }
          ]
      }
		]
	})

  
  w2ui['layout'].html('top', w2ui['main-toolbar']);
	w2ui['layout'].html('left', w2ui['left-pane']);
  w2ui['left-pane'].html('top', w2ui['navigation-toolbar']);
  w2ui['left-pane'].html('main', w2ui['navigation']);
	w2ui['left-pane'].html('bottom', w2ui['filter']);
  
});

</script>

<script type='text/javascript' src='./test.js'></script>
<script type="module">
    const height = 1000;
    
    const width = 1000;
    
    var k = height / width
    
    var artiJson = await d3.json("artifacts.json")
    console.log(artiJson);
    data = artiJson.UluburunShipwreck.artifact.map(a => a = {location: a.location.map((l, index) => assembleFragment(l, a._name, index)), description: a.description, _type: a._type, _name: a._name});
    
    
    
    
    
    
    
    /**
     * @description
     * Takes an Array<V>, and a grouping function,
     * and returns a Map of the array grouped by the grouping function.
     *
     * @param list An array of type V.
     * @param keyGetter A Function that takes the the Array type V as an input, and returns a value of type K.
     *                  K is generally intended to be a property key of V.
     *
     * @returns Map of the array grouped by the grouping function.
     */
    //export function groupBy<K, V>(list: Array<V>, keyGetter: (input: V) => K): Map<K, Array<V>> {
    //    const map = new Map<K, Array<V>>();
    function groupBy(list, keyGetter) {
        const map = new Map();
        list.forEach((item) => {
             const key = keyGetter(item);
             const collection = map.get(key);
             if (!collection) {
                 map.set(key, [item]);
             } else {
                 collection.push(item);
             }
        });
        return map;
    }
    
      var o = data.map(a => a = {head: a.location[0].x + " " + a.location[0].y, others: a})
      objs = []
      var mid = groupBy(o, o => o.head)
        mid.forEach((v, k) => objs.push({location: {x: k.slice(0,2), y: k.slice(3)}, objects: v.map(x => x.others)})) ////// AAAAAAAAAA
    
    function assembleFragment(s, objName, index) {
      var loc = s.split(" ");
      const y = alphaToInt(loc[0][0])
      const x = loc[0].slice(1)
      
      const id = objName + "-" + "(" + x + ", " + y + ")" + "-" + index;
      
      return {id: id, x: x, y:y};
    }
    
    var alphaIntDic = d3.range(17).map(i => String.fromCharCode(65 + i)) //dont need this but i was tired mkay?
    
    function alphaToInt(a) {
      return a.charCodeAt(0) - 65;
    }
    
    function intToAlpha(n) {
      return String.fromCharCode(n+65);
    }
    
    var y = d3.scaleLinear()
        .domain(d3.extent(objs.map(a => a.location), d => d.y)).nice() //hOW TO MAKE EQUAL SIZED TICKS?
        .range([height, 0])
        
    var x = d3.scaleLinear()
        .domain(d3.extent(objs.map(a => a.location), d => d.x)).nice() // how to LIMIT SCROLL
        .range([0, width])
        
    function xAxis(g, x) {
        g.attr("transform", `translate(0,${height})`)
        .call(d3.axisTop(x).ticks(12))
        .call(g => g.select(".domain").attr("display", "none"))
        }
        
    function yAxis(g, y) {
        g.call(d3.axisRight(y).ticks(12 * k))
        .call(g => g.select(".domain").attr("display", "none"))
        }
        
    function grid(g, x, y) {
        g.attr("stroke", "currentColor")
        .attr("stroke-opacity", 0.1)
        .call(g => g
          .selectAll(".x")
          .data(x.ticks(12))
          .join(
            enter => enter.append("line").attr("class", "x").attr("y2", height),
            update => update,
            exit => exit.remove()
          )
            .attr("x1", d => 0.5 + x(d))
            .attr("x2", d => 0.5 + x(d)))
        .call(g => g
          .selectAll(".y")
          .data(y.ticks(12 * k))
          .join(
            enter => enter.append("line").attr("class", "y").attr("x2", width),
            update => update,
            exit => exit.remove()
          )
            .attr("y1", d => 0.5 + y(d))
            .attr("y2", d => 0.5 + y(d)));
            }
            
    var margin = ({top: 25, right: 20, bottom: 35, left: 40})
      
      const svg = d3.select("#map").append("svg")
      .attr("viewBox", [0, 0, width, height]);
      
    
    
      const gGrid = svg.append("g")
    
      const gx = svg.append("g")
    
      const gy = svg.append("g")
      
      const chart2 = svg.append("g")
      const chart = chart2.append("g")
    
      // Clipping path for the map, above the main chart so that the clipping doesn't move with the pan and zoom
      
      chart2.append('defs')
              .append('clipPath') // wont plot look at the zoomable scatter plots plotting
              .attr('id', 'clip')
              .append('rect')
                  .attr('x', 30)
                 .attr('y', 0)
                  .attr('width', width-100)
                  .attr('height', height-100);
      chart2.attr("clip-path", "url(#clip)")
    
    
      // Basic bg Image
      chart.append("image")
      .attr("xlink:href", "http://www.superiortrips.com/ShipwreckImages/AlgomaSiteMap.jpg")
    
    
      let transform;
    
      // Plot the points on the map
      const points = chart.append("g")
        .selectAll("points")
        .data(objs)
        .join("circle")
          .attr("cx", d => x(d.location.x))
         .attr("cy", d => y(d.location.y))
          .attr("stroke", "green")
          .attr("data", d => (d))
          .attr("r", 10)
          .attr("locations", d => d.location)
          .attr("id", d =>  "point" + d.location.x + "-" + d.location.y + "")
      .style("cursor", "pointer")
            .attr("visibility", "hidden")
          .on("click", mapIconClicked)
    
        //add text labels
      const pointsLabels = chart.append("g")
        .selectAll("pointLabelText")
        .data(objs)
        .join("text")
          .attr("x", d => x(d.location.x))
          .attr("y", d => y(d.location.y))
          .attr("id", d =>  "text" + d.location.x + "-" + d.location.y + "")
          .attr("visibility", "hidden")
          .attr("transform", d => `rotate(-45,${x(d.location.x)},${y(d.location.y)})`)
          .text(d => getText(d))
    
      function getText(d) {
        var text = d.objects[0]._name //HOW DO WE KNOW WHICH ONE IS THE TOP ONE???
        if (d.objects.length > 1) {
          text += " +" + (d.objects.length - 1)
        }
        return text
      }
                
      const lines = chart.append("g");
      const overlap = chart.append("g");
    
      // When an object dot is clicked
      function objectClicked(event, p) {
        overlap.selectAll("*").remove();
        lines.append("g")
          .attr("stroke", "red")
          .attr("stroke-opacity", 0.6)
          .selectAll("links")
          .data(p.others.map((frag, index, array) => frag = {x: frag.x, y: frag.y, xNext: array[(index + 1) % array.length].x, yNext: array[(index + 1) % array.length].y}).flat())
          .join("line")
            .attr("x1", d => x(d.x))
            .attr("y1", d => y(d.y))
            .attr("x2", d => x(d.xNext))
            .attr("y2", d => y(d.yNext));
      }
    
      // When a dot on the map is clicked, if there are multiple do that functions
      
      function mapIconClicked(event, p) {
        overlap.selectAll("*").remove();
        lines.selectAll("*").remove();
        if (p.objects.length > 1) {
            multiobjectClicked(event, p)
        } else {
            objectClicked(event, p.objects[0])
        }
      }
    
      // When a location with multiple objects is clicked on
      function multiobjectClicked(event, p) {
       overlap.append("g")
          .attr("stroke", "steelblue")
          .attr("stroke-width", 1.5)
          .attr("fill", "red")
          .selectAll("overlap")
        .data(p.objects)
          .join("circle")
          .attr("cx", d => x(p.location.x))
            .attr("cy", (d, i) => y(p.location.y) - i * 10)
            .attr("r", 10)
            .on("click", objectClicked)
          .style("cursor", "pointer")
      }
      
      // ID
      chart.append("g")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
        .selectAll("text")
        .data(data)
        .join("text")
          .attr("dy", "0.35em")
          .attr("x", d => x(d.x) + 7)
          .attr("y", d => y(d.y))
          .text(d => d.id);
    
    const zoom = d3.zoom().scaleExtent([0.5, 32])
          .on("zoom", zoomed)
    
    function zoomed({transform}) {
      console.log(transform)
        const zx = transform.rescaleX(x).interpolate(d3.interpolateRound);
        const zy = transform.rescaleY(y).interpolate(d3.interpolateRound);
        gx.call(xAxis, zx);
       gy.call(yAxis, zy);
        chart.attr("transform", transform).attr("stroke-width", 5 / transform.k);
        chart.style("stroke-width", 3 / Math.sqrt(transform.k));
        points.attr("r", 10 / Math.sqrt(transform.k));
      gGrid.call(grid, zx, zy)
      };
              
      svg.call(zoom)
        .call(zoom.transform, d3.zoomIdentity)
    
      Object.assign(svg.node(), {
        reset() {
          svg.transition()
              .duration(750)
              .call(zoom.transform, d3.zoomIdentity);
        }
      });
      function objectToNode(object) {
        var objectName = object._name;
        var locations = object.location;
        var mainNode = {id: objectName, text: objectName, node: locations.map((f, i) => fragmentToNode(f, i, objectName)) };
        return mainNode;
      }
      
      function fragmentToNode(fragment, index, objectName) {
            var fragmentName = "(" + fragment.x + ", " + fragment.y + ")";
            return { id: objectName + "-" + fragmentName + "-" + index + "-button", text: fragmentName, onClick: function(event) {
                
            d3.select("#" + "point" + fragment.x + "-" + fragment.y + "").attr("r", 100)
            }}
      }
      
      var nodes = data.map(objectToNode);
      w2ui['navigation'].add(nodes);

      /* Var setting */
      objectsByDots = objs.map(e => ({svgNode: document.getElementById("point" + e.location.x + "-" + e.location.y),
                                      textNode: document.getElementById("text" + e.location.x + "-" + e.location.y),
                                      location:e.location, 
                                      objects: []}))

      // Divider
      loadState(null)
      
      /*
      console.log(data)
        data.forEach((object) => {
            var objectName = object._name;
            var locations = object.location;
            w2ui['navigation'].add({ id: objectName, text: objectName });
            locations.forEach((fragment, index) => {
                var fragmentName = "(" + fragment.x + ", " + fragment.y + ")";
                w2ui['navigation'].add(objectName, ({ id: objectName + "-" + fragmentName + "-" + index + "-button", text: fragmentName, onClick: function(event) {
                
                d3.select("#" + "point" + fragment.x + "-" + fragment.y + "").attr("r", 100)
                }}));
                
                // this takes a bit maybe we should pregen it
                
                
            });
        });
        */
        
    /*
    import define from "./index.js";
    import {Runtime, Library, Inspector} from "./runtime.js";
    const runtime = new Runtime();
        // Inspector.into(document.body)
    const main = runtime.module(define, Inspector.into(document.getElementById("map")));
    // const main = runtime.module(define, name => {
    // 	console.log(name);
    // 	if (name == 'replay1') {
    // 		console.log(define);
    // 		console.log("Query");
    // 		console.log(document.querySelection("#map"));
    // 		console.log("ID");
    // 		console.log(document.getElementById("map"));
    // 		return new Inspector.into(document.body);
    // 	}
    // });
    */
    
</script>
<script type='text/javascript'>
  var state;

  function loadState(loaded) {
    if (loaded == null) {
      var objectStates = data.map(o => ({id: o._name, 
                                    hidden: true,
                                    fragments: o.location.map((f, index) => ({id: getFragmentName(f.x, f.y, index), hidden: false}))
                                  }));

      state = {filters: {rocks: true, lines: true}, objectStates: objectStates};
      console.log(state)
      loadState(state);
      console.log(state)
    } else {
      loaded.objectStates.forEach(o => {hideObject(o.id, o.hidden)});
    } 
  }

  function hideObject(id, hide) {
    state.objectStates.find(o => o.id == id).hidden = hide;

    let object = data.find(o => o._name == id);
    console.log(object)
    let locationsToUpdate = objectsByDots.filter(e => object.location.some(l => compareLocation(e.location, l)));

    if (hide) {
      locationsToUpdate.forEach(e => e.objects = e.objects.filter(o => o._name != object._name))
      locationsToUpdate.forEach(svgloc => {
          if (svgloc.objects.length == 0) {
              svgloc.svgNode.setAttribute("visiblity", "hidden")
              svgloc.textNode.setAttribute("visibility", "hidden")
          } else {
              if (svgloc.objects.length == 1) {
                  svgloc.textNode.innerHTML = svgloc.objects[0]._name
              } else {
                  svgloc.textNode.innerHTML = svgloc.objects[0]._name + " +" + (svgloc.objects.length - 1)
              }
          }
      });
    } else {
      locationsToUpdate.forEach(e => { e.objects.push(object)})
      console.log(locationsToUpdate)
      locationsToUpdate.forEach(svgloc => {
          svgloc.svgNode.setAttribute("visibility", "visible")
          svgloc.textNode.setAttribute("visibility", "visible")
          if (svgloc.objects.length == 1) {
              svgloc.textNode.innerHTML = svgloc.objects[0]._name
          } else {
              svgloc.textNode.innerHTML = svgloc.objects[0]._name + " +" + (svgloc.objects.length - 1)
          }
      });
    }
  }
  

  function hideFragment(id) {

  }

  function saveToCode() {
    console.log("saving")
    return JSON.stringify(state)
    
  }

  function loadFromCode(code) {
    try {
      // Probably need to regex
      state = JSON.parse(code)
      loadState(state)
    } catch (e) {
      if (e instanceof SyntaxError) {
        w2alert('Invalid code')
      } else {
        w2alert('Something bad happened, please email kaltagkaasen@gmail.com with what you did, becuase frankly I did not expect anything to happen. :)')
      }
    }
  }

</script>

</body>
</html>
